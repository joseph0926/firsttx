{
  "Hero": {
    "badge": "CSR 재방문에서 빈 화면을 없애는 3가지 레이어",
    "title": "CSR 재방문, 기다림 없이 복구",
    "subtitle": "마지막 화면을 저장·동기화·롤백까지 한 번에 처리합니다.",
    "bodyLine1": "FirstTx는 Prepaint, Local-First, Tx 세 레이어로 구성된 툴킷입니다.",
    "bodyLine2": "CSR 아키텍처는 그대로 유지하면서, 재방문 화면 복원과 오프라인 내구성, 안전한 낙관적 업데이트를 한 번에 갖춥니다.",
    "ctaInstall": "npm 패키지로 바로 설치하기",
    "ctaPlayground": "Playground 열어보기",
    "tagInternal": "내부 도구 / 대시보드",
    "tagOffline": "오프라인 우선 앱",
    "tagLargeCsr": "큰 CSR 코드베이스"
  },
  "Navbar": {
    "tagline": "Prepaint · Local-First · Tx",
    "menuProduct": "제품",
    "menuQuickstart": "빠른 시작",
    "menuPlayground": "Playground",
    "menuGithub": "GitHub",
    "menuDocs": "Docs 홈",
    "ctaStart": "빠르게 시작하기"
  },
  "HeaderRow": {
    "eyebrow": "THREE LAYERS · ONE TOOLKIT",
    "title": "Prepaint + Local-First + Tx",
    "description": "한 번에 도입할 필요는 없습니다. 재방문 최적화만 필요하다면 Prepaint부터, 동기화/낙관적 UI가 필요하다면 Local-First와 Tx만 가져올 수도 있습니다.",
    "chipReact": "React 19 + CSR 환경 최적화",
    "chipVite": "Vite / SPA / 내부 도구",
    "chipOptional": "선택적 레이어 도입"
  },
  "Layers": {
    "layerBadge": "LAYER {order}",
    "items": {
      "prepaint": {
        "name": "Prepaint",
        "role": "Render layer",
        "description": "마지막 화면을 DOM 스냅샷으로 저장했다가, 다음 방문 시 0ms로 복원합니다.",
        "points": ["IndexedDB에 전체 화면 스냅샷 보관", "재방문 시 React 로딩 전에 즉시 복원", "CSR 구조 그대로, SSR 수준의 revisit 경험"]
      },
      "localFirst": {
        "name": "Local-First",
        "role": "Data layer",
        "description": "IndexedDB를 단일 소스로 두고, 서버 동기화를 자동화합니다.",
        "points": ["zod 기반 타입 세이프 모델 정의", "TTL과 staleness 메타데이터 제공", "백그라운드 동기화로 오프라인 친화적"]
      },
      "tx": {
        "name": "Tx",
        "role": "Execution layer",
        "description": "UI 업데이트를 트랜잭션으로 묶어 낙관적 업데이트를 안전하게 만듭니다.",
        "points": ["여러 단계의 업데이트를 하나의 트랜잭션으로 실행", "실패 시 자동 롤백(compensate) 처리", "네트워크 오류에도 일관된 UI 상태 유지"]
      }
    }
  },
  "Experience": {
    "eyebrow": "HOW IT FEELS",
    "title": "유저 입장에서 보는 FirstTx 경험",
    "description": "첫 방문의 SSR 이점은 인정하지만, 실제로는 재방문·탭 이동·뒤로 가기 같은 맥락이 더 많습니다. FirstTx는 이 순간에 집중해 “다시 왔을 때도 이미 준비된 화면”을 만듭니다.",
    "cards": [
      { "title": "재방문이 잦은 내부 도구", "description": "목록-상세-목록을 반복해서 오가는 CRM, 어드민, 대시보드에서 빈 화면 없이 바로 이전 상태를 보여줍니다." },
      { "title": "작업 중 새로고침", "description": "로컬 모델이 최신 스냅샷을 들고 있어, 실수로 새로고침해도 작업 맥락이 그대로 유지됩니다." },
      { "title": "낙관적 UI의 실패 핸들링", "description": "서버 에러로 롤백할 때도 UI 상태는 트랜잭션 단위로 되돌아가 ‘반쯤만 롤백된 화면’을 피합니다." },
      { "title": "오프라인 내구성", "description": "구현은 단순한 동기화 훅이지만 결과적으로 오프라인/재연결을 견디는 데이터 레이어가 됩니다." }
    ]
  },
  "Timeline": {
    "title": "Live timeline (DevTools)",
    "legend": "prepaint · model · tx",
    "rows": [
      { "label": "prepaint.restore", "badge": "Prepaint", "status": "success", "detail": "IndexedDB 스냅샷 → DOM 복원 (4ms)" },
      { "label": "model.sync.start", "badge": "Local-First", "status": "pending", "detail": "TTL 초과로 백그라운드 동기화 시작" },
      { "label": "tx.commit", "badge": "Tx", "status": "success", "detail": "UI 업데이트와 서버 요청 모두 성공" },
      { "label": "tx.rollback", "badge": "Tx", "status": "error", "detail": "네트워크 실패 → compensate로 UI 상태 되돌림" }
    ],
    "footnote": "Chrome 확장 프로그램 FirstTx DevTools에서 위 이벤트를 타임라인으로 볼 수 있습니다."
  },
  "QuickStart": {
    "eyebrow": "QUICK START",
    "title": "세 줄 설치로 시작하는 FirstTx",
    "description": "가장 일반적인 케이스는 세 패키지를 모두 설치하는 것입니다. 필요에 따라 Prepaint / Local-First / Tx만 선택적으로 도입할 수도 있습니다.",
    "chipSpa": "React SPA / Vite 템플릿",
    "chipPartial": "부분 도입 가능",
    "installLabel": "Install",
    "installBadge": "pnpm / npm / yarn",
    "stepVite": "1. Vite 플러그인 설정",
    "stepEntry": "2. 엔트리 포인트 교체",
    "snippetModelTitle": "Local-First 모델 + 동기화 훅",
    "snippetTxTitle": "Tx로 낙관적 업데이트를 트랜잭션으로 묶기",
    "snippetTxDescription": "서버 요청 전 UI를 먼저 업데이트하고, 실패 시 자동 롤백하는 패턴을 안전하게 캡슐화합니다."
  },
  "Footer": {
    "copyright": "© 2025 FirstTx. MIT 라이선스. CSR-first 팀을 위해 만들었습니다.",
    "github": "GitHub",
    "playground": "Playground"
  }
}
